const { Client, LocalAuth } = require('whatsapp-web.js');
const qrcode = require('qrcode-terminal');
const axios = require('axios');

const client = new Client({
    authStrategy: new LocalAuth(),
    puppeteer: {
        args: ['--no-sandbox', '--disable-setuid-sandbox']
    }
});

// Configura√ß√£o da API DeepSeek
const DEEPSEEK_API_KEY = process.env.DEEPSEEK_API_KEY || 'sk-2cec3a55cf5645a283c9cc555b259cb6';
const DEEPSEEK_URL = 'https://api.deepseek.com/v1/chat/completions';

// Banco de dados em mem√≥ria
let groupData = {};

client.on('qr', (qr) => {
    console.log('üì± Escaneie este QR code com seu WhatsApp:');
    qrcode.generate(qr, {small: true});
});

client.on('ready', () => {
    console.log('‚úÖ Bot com IA conectado!');
    console.log('üß† Usando DeepSeek para categoriza√ß√£o inteligente');
});

client.on('message', async (message) => {
    if (message.from === 'status@broadcast' || message.from === 'broadcast') return;
    if (message.type === 'broadcast') return;
    
    try {
        const response = await processSmartMessage(message);
        if (response) {
            message.reply(response);
        }
    } catch (error) {
        console.error('Erro:', error);
        message.reply('‚ùå Erro ao processar mensagem. Tente novamente.');
    }
});

// Fun√ß√£o principal com IA
async function processSmartMessage(message) {
    const groupId = message.from;
    const userMessage = message.body.trim();
    
    if (!userMessage) return null;
    
    console.log(`üí¨ Mensagem de ${getSenderName(message)}: ${userMessage}`);

    // Inicializar grupo se n√£o existir
    if (!groupData[groupId]) {
        groupData[groupId] = await detectGroupTypeWithAI(userMessage);
    }
    
    const groupType = groupData[groupId].type;
    
    // Comandos especiais
    if (userMessage.toLowerCase() === '!ajuda') {
        return getHelpMessage(groupType);
    }
    
    if (userMessage.toLowerCase() === '!limpar') {
        return clearGroupData(groupId);
    }
    
    if (userMessage.toLowerCase() === '!status') {
        return getGroupStatus(groupId, groupType);
    }
    
    if (userMessage.toLowerCase() === '!tipo') {
        return `üìä Este grupo est√° configurado como: *${groupType}*`;
    }

    // Processamento com IA baseado no tipo de grupo
    switch(groupType) {
        case 'entretenimento':
            return await processEntertainmentItemWithAI(userMessage, groupId);
        case 'gastos':
            return await processExpenseItemWithAI(userMessage, groupId);
        case 'compras':
            return await processShoppingItemWithAI(userMessage, groupId);
        default:
            const detectedType = await detectGroupTypeWithAI(userMessage);
            groupData[groupId].type = detectedType.type;
            return await processMessageByTypeWithAI(userMessage, groupId, detectedType.type);
    }
}

// üß† FUN√á√ÉO PRINCIPAL DE IA
async function callDeepSeekAI(prompt, systemMessage = "Voc√™ √© um assistente √∫til.") {
    try {
        const response = await axios.post(DEEPSEEK_URL, {
            model: 'deepseek-chat',
            messages: [
                {
                    role: 'system',
                    content: systemMessage
                },
                {
                    role: 'user',
                    content: prompt
                }
            ],
            max_tokens: 500,
            temperature: 0.3
        }, {
            headers: {
                'Authorization': `Bearer ${DEEPSEEK_API_KEY}`,
                'Content-Type': 'application/json'
            },
            timeout: 10000
        });

        return response.data.choices[0].message.content.trim();
    } catch (error) {
        console.error('Erro na API DeepSeek:', error);
        throw new Error('Falha na comunica√ß√£o com IA');
    }
}

// üé¨ PROCESSAMENTO DE ENTRETENIMENTO COM IA
async function processEntertainmentItemWithAI(message, groupId) {
    if (message.length < 2) return null;
    
    try {
        // Usar IA para categorizar o conte√∫do
        const categoryPrompt = `Categorize este conte√∫do de entretenimento em UMA destas categorias: filme, s√©rie, desenho, document√°rio, anime, livro, outros.

Conte√∫do: "${message}"

Responda APENAS com o nome da categoria, sem explica√ß√µes.`;
        
        const category = await callDeepSeekAI(categoryPrompt, "Voc√™ √© um especialista em categoriza√ß√£o de conte√∫do de entretenimento.");
        
        // Adicionar √† lista
        if (!groupData[groupId].items) groupData[groupId].items = [];
        
        const existingItem = groupData[groupId].items.find(i => 
            i.name.toLowerCase() === message.toLowerCase()
        );
        
        if (!existingItem) {
            groupData[groupId].items.push({
                name: message,
                category: category.toLowerCase(),
                added: new Date().toLocaleDateString('pt-BR'),
                addedBy: getSenderName({...message, _data: { notifyName: getSenderName(message) }})
            });
            
            return `üé¨ "${message}" adicionado como ${category}!`;
        } else {
            return `‚ÑπÔ∏è "${message}" j√° est√° na lista como ${existingItem.category}.`;
        }
        
    } catch (error) {
        // Fallback para categoriza√ß√£o manual se IA falhar
        return processEntertainmentItemFallback(message, groupId);
    }
}

// üí∞ PROCESSAMENTO DE GASTOS COM IA
async function processExpenseItemWithAI(message, groupId) {
    try {
        // Usar IA para extrair valor e categorizar
        const expensePrompt = `Analise esta mensagem de gasto e extraia: descri√ß√£o e valor. Tamb√©m categorize em UMA destas: mercado, transporte, lazer, comida, sa√∫de, educa√ß√£o, contas, outros.

Mensagem: "${message}"

Responda no formato JSON:
{
  "descricao": "descri√ß√£o extra√≠da",
  "valor": n√∫mero,
  "categoria": "categoria"
}

Apenas o JSON, sem outros textos.`;

        const aiResponse = await callDeepSeekAI(expensePrompt, "Voc√™ √© um especialista em an√°lise de gastos financeiros.");
        
        // Extrair JSON da resposta
        const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
        if (!jsonMatch) throw new Error('Resposta da IA n√£o cont√©m JSON');
        
        const expenseData = JSON.parse(jsonMatch[0]);
        
        if (!expenseData.descricao || !expenseData.valor || !expenseData.categoria) {
            throw new Error('Dados incompletos da IA');
        }
        
        // Adicionar gasto
        if (!groupData[groupId].items) groupData[groupId].items = [];
        
        groupData[groupId].items.push({
            description: expenseData.descricao,
            value: parseFloat(expenseData.valor),
            category: expenseData.categoria.toLowerCase(),
            date: new Date().toLocaleDateString('pt-BR'),
            addedBy: getSenderName({...message, _data: { notifyName: getSenderName(message) }}),
            originalMessage: message
        });
        
        // Mostrar resumo a cada 3 gastos
        const itemCount = groupData[groupId].items.length;
        if (itemCount % 3 === 0 || itemCount === 1) {
            return getExpensesSummaryWithAI(groupId);
        } else {
            return `‚úÖ Gasto registrado: ${expenseData.descricao} - R$ ${parseFloat(expenseData.valor).toFixed(2)} (${expenseData.categoria})`;
        }
        
    } catch (error) {
        console.error('Erro na categoriza√ß√£o de gastos:', error);
        return processExpenseItemFallback(message, groupId);
    }
}

// üõí PROCESSAMENTO DE COMPRAS COM IA
async function processShoppingItemWithAI(message, groupId) {
    if (message.toLowerCase().includes('mostrar') || message.toLowerCase().includes('lista')) {
        return getShoppingList(groupId);
    }
    
    try {
        // Usar IA para identificar e organizar itens de compras
        const shoppingPrompt = `Esta √© uma lista de compras. Identifique cada item individualmente. Se for uma lista com v√≠rgulas, separe os itens. Se for uma frase, extraia os itens mencionados.

Mensagem: "${message}"

Responda com uma lista JSON de itens:
{
  "itens": ["item1", "item2", "item3"]
}

Apenas o JSON, sem outros textos.`;

        const aiResponse = await callDeepSeekAI(shoppingPrompt, "Voc√™ √© um especialista em organiza√ß√£o de listas de compras.");
        
        const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
        if (!jsonMatch) throw new Error('Resposta da IA n√£o cont√©m JSON');
        
        const shoppingData = JSON.parse(jsonMatch[0]);
        
        if (!shoppingData.itens || !Array.isArray(shoppingData.itens)) {
            throw new Error('Formato inv√°lido da IA');
        }
        
        const items = shoppingData.itens.map(item => item.trim()).filter(item => item);
        
        if (items.length === 0) {
            return "üõí N√£o identifiquei itens na sua mensagem. Tente: 'leite, p√£o, ovos'";
        }
        
        if (!groupData[groupId].items) groupData[groupId].items = [];
        
        let addedCount = 0;
        items.forEach(item => {
            if (!groupData[groupId].items.find(i => i.toLowerCase() === item.toLowerCase())) {
                groupData[groupId].items.push(item);
                addedCount++;
            }
        });
        
        if (addedCount === 0) {
            return "‚ÑπÔ∏è Todos os itens j√° est√£o na lista!";
        }
        
        return `üõí ${addedCount} item(s) adicionado(s) pela IA! Lista atual: ${groupData[groupId].items.length} itens.`;
        
    } catch (error) {
        console.error('Erro na categoriza√ß√£o de compras:', error);
        return processShoppingItemFallback(message, groupId);
    }
}

// üß† DETEC√á√ÉO DE TIPO DE GRUPO COM IA
async function detectGroupTypeWithAI(message) {
    try {
        const detectionPrompt = `Analise esta mensagem e determine se √© sobre:
1. "entretenimento" - filmes, s√©ries, livros, coisas para assistir/ler
2. "gastos" - despesas, dinheiro, compras com valores
3. "compras" - lista de compras, mercado, itens para comprar

Mensagem: "${message}"

Responda APENAS com uma palavra: "entretenimento", "gastos" ou "compras".`;

        const aiResponse = await callDeepSeekAI(detectionPrompt, "Voc√™ √© um especialista em categoriza√ß√£o de conversas.");
        
        const detectedType = aiResponse.toLowerCase().trim();
        const validTypes = ['entretenimento', 'gastos', 'compras'];
        
        return { 
            type: validTypes.includes(detectedType) ? detectedType : 'compras', 
            items: [] 
        };
        
    } catch (error) {
        console.error('Erro na detec√ß√£o de tipo:', error);
        // Fallback para detec√ß√£o manual
        return detectGroupTypeFallback(message);
    }
}

// üìä RESUMO DE GASTOS COM AN√ÅLISE IA
async function getExpensesSummaryWithAI(groupId) {
    const items = groupData[groupId].items;
    if (!items || items.length === 0) return "üí∞ Nenhum gasto registrado ainda!";
    
    // Calcular totais
    const byCategory = {};
    let total = 0;
    
    items.forEach(item => {
        if (!byCategory[item.category]) {
            byCategory[item.category] = { total: 0, items: [] };
        }
        byCategory[item.category].total += item.value;
        byCategory[item.category].items.push(item);
        total += item.value;
    });
    
    // Gerar an√°lise com IA
    let analysis = "";
    try {
        const analysisPrompt = `Analise estes gastos e d√™ uma breve an√°lise (m√°ximo 2 frases):
Total: R$ ${total.toFixed(2)}
Categorias: ${Object.entries(byCategory).map(([cat, data]) => `${cat}: R$ ${data.total.toFixed(2)}`).join(', ')}

D√™ uma an√°lise objetiva.`;
        
        analysis = await callDeepSeekAI(analysisPrompt, "Voc√™ √© um consultor financeiro.");
        analysis = `\nüí° ${analysis}`;
    } catch (error) {
        analysis = "";
    }
    
    let response = `üí∞ *RESUMO DE GASTOS* - Total: R$ ${total.toFixed(2)}\n`;
    response += `üìä ${items.length} gastos registrados\n\n`;
    
    // Ordenar categorias por valor gasto
    const sortedCategories = Object.keys(byCategory).sort((a, b) => 
        byCategory[b].total - byCategory[a].total
    );
    
    sortedCategories.forEach(category => {
        const catData = byCategory[category];
        const percentage = ((catData.total / total) * 100).toFixed(1);
        
        response += `üìÅ *${category.toUpperCase()}* - R$ ${catData.total.toFixed(2)} (${percentage}%)\n`;
    });
    
    response += analysis;
    response += `\nüí° Adicione gastos descrevendo o que foi e o valor`;
    
    return response;
}

// üîÑ FUN√á√ïES FALLBACK (se IA falhar)
function processEntertainmentItemFallback(message, groupId) {
    const item = message.trim();
    if (item.length < 3) return null;
    
    const category = detectEntertainmentCategoryFallback(item);
    
    if (!groupData[groupId].items) groupData[groupId].items = [];
    
    const existingItem = groupData[groupId].items.find(i => i.name.toLowerCase() === item.toLowerCase());
    
    if (!existingItem) {
        groupData[groupId].items.push({
            name: item,
            category: category,
            added: new Date().toLocaleDateString('pt-BR'),
            addedBy: getSenderName({...message, _data: { notifyName: getSenderName(message) }})
        });
        
        return `üé¨ "${item}" adicionado como ${category}! (fallback)`;
    }
    
    return `‚ÑπÔ∏è "${item}" j√° est√° na lista como ${existingItem.category}.`;
}

function processExpenseItemFallback(message, groupId) {
    let description, value;
    
    let match = message.match(/(.+?)\s+([\d,\.]+)$/);
    if (match) {
        description = match[1].trim();
        value = parseFloat(match[2].replace(',', '.'));
    } else {
        match = message.match(/([\d,\.]+)\s+(.+)$/);
        if (match) {
            value = parseFloat(match[1].replace(',', '.'));
            description = match[2].trim();
        }
    }
    
    if (!match || isNaN(value)) {
        return "üí∞ Formato: 'descri√ß√£o valor' \nEx: 'uber 15' ou 'pizza 40,50'";
    }
    
    const category = detectExpenseCategoryFallback(description);
    
    if (!groupData[groupId].items) groupData[groupId].items = [];
    
    groupData[groupId].items.push({
        description: description,
        value: value,
        category: category,
        date: new Date().toLocaleDateString('pt-BR'),
        addedBy: getSenderName({...message, _data: { notifyName: getSenderName(message) }})
    });
    
    const itemCount = groupData[groupId].items.length;
    if (itemCount % 3 === 0 || itemCount === 1) {
        return getExpensesSummaryWithAI(groupId);
    } else {
        return `‚úÖ Gasto registrado: ${description} - R$ ${value.toFixed(2)} (${category})`;
    }
}

function processShoppingItemFallback(message, groupId) {
    const items = message.split(',').map(item => item.trim()).filter(item => item);
    
    if (items.length === 0) {
        return "üõí Formato: 'item1, item2, item3'";
    }
    
    if (!groupData[groupId].items) groupData[groupId].items = [];
    
    let addedCount = 0;
    items.forEach(item => {
        if (!groupData[groupId].items.find(i => i.toLowerCase() === item.toLowerCase())) {
            groupData[groupId].items.push(item);
            addedCount++;
        }
    });
    
    if (addedCount === 0) {
        return "‚ÑπÔ∏è Todos os itens j√° est√£o na lista!";
    }
    
    return `üõí ${addedCount} item(s) adicionado(s)! Lista atual: ${groupData[groupId].items.length} itens.`;
}

function detectGroupTypeFallback(message) {
    const lowerMsg = message.toLowerCase();
    
    if (lowerMsg.includes('assistir') || lowerMsg.includes('filme') || lowerMsg.includes('s√©rie') || lowerMsg.includes('serie')) {
        return { type: 'entretenimento', items: [] };
    }
    
    if (lowerMsg.includes('gasto') || lowerMsg.includes('gastar') || /\d+/.test(message)) {
        return { type: 'gastos', items: [] };
    }
    
    return { type: 'compras', items: [] };
}

// üéØ FUN√á√ïES DE CATEGORIZA√á√ÉO FALLBACK
function detectEntertainmentCategoryFallback(item) {
    const lowerItem = item.toLowerCase();
    
    if (lowerItem.includes('s√©rie') || lowerItem.includes('serie') || lowerItem.includes('temp') || lowerItem.includes('season')) {
        return 's√©rie';
    }
    if (lowerItem.includes('filme') || lowerItem.includes('movie')) {
        return 'filme';
    }
    if (lowerItem.includes('desenho') || lowerItem.includes('anime')) {
        return 'desenho';
    }
    if (lowerItem.includes('doc') || lowerItem.includes('document√°rio')) {
        return 'document√°rio';
    }
    if (lowerItem.includes('livro') || lowerItem.includes('book')) {
        return 'livro';
    }
    
    return 'outros';
}

function detectExpenseCategoryFallback(description) {
    const desc = description.toLowerCase();
    
    if (desc.includes('uber') || desc.includes('t√°xi') || desc.includes('transporte')) {
        return 'transporte';
    }
    if (desc.includes('mercado') || desc.includes('super') || desc.includes('compras')) {
        return 'mercado';
    }
    if (desc.includes('restaurant') || desc.includes('comida') || desc.includes('pizza')) {
        return 'comida';
    }
    if (desc.includes('cinema') || desc.includes('lazer')) {
        return 'lazer';
    }
    if (desc.includes('farmacia') || desc.includes('sa√∫de')) {
        return 'sa√∫de';
    }
    if (desc.includes('curso') || desc.includes('livro') || desc.includes('educa√ß√£o')) {
        return 'educa√ß√£o';
    }
    
    return 'outros';
}

// üìã FUN√á√ïES AUXILIARES (mantidas do c√≥digo anterior)
function getShoppingList(groupId) {
    const items = groupData[groupId].items;
    if (!items || items.length === 0) return "üõí Lista de compras vazia!";
    
    let response = `üõí *LISTA DE COMPRAS* (${items.length} itens)\n\n`;
    
    items.forEach((item, index) => {
        response += `${index + 1}. ${item}\n`;
    });
    
    return response;
}

function clearGroupData(groupId) {
    const count = groupData[groupId].items ? groupData[groupId].items.length : 0;
    groupData[groupId].items = [];
    return `üóëÔ∏è Lista limpa! ${count} itens removidos.`;
}

function getGroupStatus(groupId, groupType) {
    const items = groupData[groupId].items;
    const count = items ? items.length : 0;
    
    switch(groupType) {
        case 'entretenimento':
            // Agrupar por categoria para mostrar distribui√ß√£o
            const categories = {};
            if (items) {
                items.forEach(item => {
                    categories[item.category] = (categories[item.category] || 0) + 1;
                });
            }
            const categoryStr = Object.entries(categories).map(([cat, qty]) => `${cat}: ${qty}`).join(', ');
            return `üé¨ Status: ${count} itens (${categoryStr})`;
        case 'gastos':
            const total = items ? items.reduce((sum, item) => sum + item.value, 0) : 0;
            return `üí∞ Status: ${count} gastos - Total: R$ ${total.toFixed(2)}`;
        case 'compras':
            return `üõí Status: ${count} itens na lista de compras`;
        default:
            return `üìä Status: ${count} itens no grupo`;
    }
}

function getSenderName(message) {
    return message._data?.notifyName || message.author || message.from.split('@')[0];
}

async function processMessageByTypeWithAI(message, groupId, type) {
    groupData[groupId].type = type;
    
    switch(type) {
        case 'entretenimento':
            return await processEntertainmentItemWithAI(message, groupId);
        case 'gastos':
            return await processExpenseItemWithAI(message, groupId);
        case 'compras':
            return await processShoppingItemWithAI(message, groupId);
        default:
            if (!groupData[groupId].items) groupData[groupId].items = [];
            groupData[groupId].items.push(message);
            return `‚úÖ Adicionado: "${message}"`;
    }
}

function getHelpMessage(groupType) {
    const baseHelp = `ü§ñ *BOT COM IA* - Usa DeepSeek para categoriza√ß√£o inteligente

Comandos:
!ajuda - Mostra esta mensagem
!limpar - Limpa os dados do grupo  
!status - Mostra status atual
!tipo - Mostra o tipo do grupo

üí° Funciona automaticamente - apenas envie suas mensagens!`;

    switch(groupType) {
        case 'entretenimento':
            return `${baseHelp}

üé¨ *Entretenimento*: Envie nomes de filmes, s√©ries, etc.
A IA categoriza automaticamente!`;
        case 'gastos':
            return `${baseHelp}

üí∞ *Gastos*: Descreva gastos com valores
Ex: "jantar 80", "uber 25", "mercado 150"`;
        case 'compras':
            return `${baseHelp}

üõí *Compras*: Liste itens para comprar
Ex: "leite, p√£o, ovos" ou "preciso comprar caf√© e a√ß√∫car"`;
        default:
            return baseHelp;
    }
}

client.initialize();